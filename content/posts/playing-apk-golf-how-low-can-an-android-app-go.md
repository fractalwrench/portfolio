---
title: "Playing APK Golf"
subtitle: "Reducing an Android APK size by 99.99% - how low can it go?"
date: 2017-10-08T16:07:19+01:00
---

I came across [this question](https://codegolf.meta.stackexchange.com/questions/10113/the-smallest-android-app-in-the-world/10114) on StackExchange asking what the smallest possible APK is, and had to try it out.

Let the APK Golf commence.

### Ground Rules
We'll start off with the default app generated by Android Studio that displays "Hello World".

However, the only hard rule is that it must be possible to install the APK on an Android device.

### Measuring a Baseline
A new project generated by Android Studio 3 Beta 6 uses the following:

- `minSdkVersion` 15
- AppCompat/Support Library
- Empty activity and layout file

The first thing we'll do is measure a baseline, so that we can quantify any performance improvements. To do this, we'll [create a keystore](https://developer.android.com/studio/publish/app-signing.html#generate-key), sign the app, and measure the file size in bytes using `stat -f%z $filename`.

We'll also install the APK on a Nexus 5x running Oreo, to make sure that the Package Manager doesn't reject it.

![Default App Screenshot](/img/apkgolf/default-app.png)

Beautiful. Our APK weighs in at approximately 1.5Mb.

### Visual Exploration
1.5Mb seems like a lot considering what our app does. Let's explore our project structure and see if there are any easy wins. Android Studio has generated:

- One `MainActivity`, which extends `AppCompatActivity`.
- One layout file with a `ConstraintLayout` root view.
- Values files containing 3 colours, 1 string resource, and 1 theme.
- One `AndroidManifest` referencing the `MainActivity`.
- The `AppCompat` and `ConstraintLayout` support libraries.
- Square, round, and foreground launcher icon PNGs.

The icons seem like the easiest target, given that there are 15 images overall, and 2 XML files under `mipmap-anydpi-v26`. Let's quantify this using the [APK Analyser](https://developer.android.com/studio/build/apk-analyzer.html).

### APK Analyser
Our APK is composed of the following files:

| File                 | Size           |
| -------------        |-------------|
| `classes.dex`        | 74% |
| res                  | 20% |
| `resources.arsc`     | 4% |
| `META-INF`           | 2% |
| `AndroidManifest.xml`| <1% |

![Apk Analyser Screenshot](/img/apkgolf/apk-analyser-1.jpg)

#### Dex file
Contrary to our gut feeling, `classes.dex` is the biggest culprit at 73%, and is therefore our first target. The dex file contains Java class definitions in the Dex format, and also references methods in the Android framework and support library.

The `android.support` package references over 13,000 methods, which seems excessive for a Hello World app.

#### Resources
Our res directory has a vast number of layout files, drawables, and animations that were not visible in our project structure. Again, these have been pulled in from the support library package, and weigh in at around 20% of the APK size.

![Apk Analyser Screenshot](/img/apkgolf/apk-analyser-2.jpg)

The `resources.arsc` file also contains a reference to each of these resources.

#### Signing
The `META-INF` folder contains `CERT.SF`, `MANIFEST.MF`, and `CERT.RSA` files, which are required for the [v1 APK signature](https://source.android.com/security/apksigning/v2#v1-verification). `MANIFEST.MF` lists the files in the APK, whereas `CERT.SF` contains a digest of `MANIFEST.MF`, and also an individual digest of each file. `CERT.RSA` contains a public key which verifies the integrity of `CERT.SF`.

![Manifest.mf](/img/apkgolf/manifest-mf.jpg)

There are no *obvious* targets here.

#### Manifest
The AndroidManifest, looks very similar to our original input file, with the exception of resource IDs, which have been replaced with integers in the `0x7F` space.

### Enable minification
We haven't tried enabling minification and resource shrinking in our app's `build.gradle` file. Let's give that a go and observe the results.

```
android {
    buildTypes {
        release {
            minifyEnabled true
            shrinkResources true
            proguardFiles getDefaultProguardFile(
              'proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}
```

```
-keep class com.fractalwrench.** { *; }
```

Setting `minifyEnabled` to true enables [Proguard](https://www.guardsquare.com/en/proguard), which strips unused code from our application. It will also obfuscate symbol names, making it harder to reverse-engineer our app.

`shrinkResources` will remove any unused resources from our APK. This can be problematic if you are using reflection in your application to access resources indirectly, but that doesn't apply to our app.

Let's build an APK and see what's changed.

### 786 Kb (50% reduction)
We've reduced our APK size by half, with no noticeable effect on our application.

If you haven't already enabled `minifyEnabled` and `shrinkResources` in your application, this is the single most important thing you should take away from this post. You can easily save several megabytes of space, with only a a couple of hours of configuration and testing.

### AppCompat, we hardly knew ye
Our `classes.dex` now takes up 57% of the APK. The majority of these methods references belong to the  `android.support` package, so we're going to get rid of it. Let's perform the following changes:


- Remove the dependencies block from our `build.gradle` entirely

```
dependencies {
    implementation 'com.android.support:appcompat-v7:26.1.0'
    implementation 'com.android.support.constraint:constraint-layout:1.0.2'
    testImplementation 'junit:junit:4.12'
}
```

- Update the MainActivity to extend `android.app.Activity` rather than `AppCompatActivity`

```
public class MainActivity extends Activity
```

- Update our layout to use a single `TextView`.

```
<?xml version="1.0" encoding="utf-8"?>
<TextView xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:gravity="center"
    android:text="Hello World!" />
```

- Delete `styles.xml` and remove the `android:theme` attribute from the ``<application>`` element in the `AndroidManifest`
- Delete `colors.xml`
- Sync gradle files

### 108 Kb bytes (87% reduction)
Holy cow, we just achieved nearly a 10x reduction from 786Kb, down to 108Kb. The only discernible change is the Toolbar colour, which now uses the default OS theme.

![No Support Library App Screenshot](/img/apkgolf/no-support-lib-app.png)

The res directory now takes up 95% of our APK size, due to all those launcher icons. If these icons were provided by our designer, then we could try [converting them to WebP](https://developer.android.com/studio/write/convert-webp.html), which is a more efficient file format supported on API 15 and above.

Fortunately, Google has already optimised our launch icons, although if this wasn't the case, you could also try running [ImageOptim](https://imageoptim.com/mac) to optimise and strip any unnecessary metadata from PNGs.

Let's be a bad citizen, and replace all our launch icons with a single 1-pixel black dot, placed in the unqualified `res/drawable` folder. Our new launch icon has been optimised with Gimp and ImageOptim down to 67 bytes, and is guaranteed to make both your designer and end-users cry.

### 6808 bytes (94% reduction)
Let's continue obliterating our resources, by optimising `resources.arsc`. This file currently references:

- 1 layout file
- 1 String used to display the app name
- 1 launcher icon drawable

Let's start at the top.

#### Layout file (6262 bytes, 9% reduction)
The Android framework will [inflate our XML file](https://developer.android.com/reference/android/view/LayoutInflater.html) into a `TextView`, then set the `contentView` of the `Activity`.

We could try removing the XML file, and doing this programmatically. This will be a tradeoff, as our `resources.arsc` and res directory will be reduced, but `classes.dex` will increase, as we will be referencing additional `TextView` methods from the Android framework.

```
TextView textView = new TextView(this);
textView.setText("Hello World!");
setContentView(textView);
```

Looks like we're down to 5710 bytes.

#### App Name (6034 bytes, 4% reduction)
Let's delete `strings.xml`, and replace `android:label` in the AndroidManifest with "A". This may seem like a small change, but will remove an entry from `resources.arsc`, a file from the res directory, and reduce the number of characters in the manifest. Every little helps.

#### Launcher icon (5300 bytes, 13% reduction)
As far as I know, there's no way to generate a PNG below 67 bytes. The [Android documentation](https://android.googlesource.com/platform/frameworks/native/+/jb-dev/libs/utils/README) also states that we need to include an integer id within `resources.arsc` that refers to our drawable resource.

These integer IDs have two namespaces:

>0x01: system resources (pre-installed in framework-res.apk)

>0x7f: application resources (bundled in the application .apk)

So what happens to our APK if we reference a resource in the 0x01 namespace? We should be able to get a nicer icon whilst simultaneously reducing our file size.

```
android:icon="@android:drawable/btn_star"
```

![System app icon Screenshot](/img/apkgolf/system-app-icon.jpg)

It goes without saying, but you should **never trust system resources** in a production application. This step will fail Google Play validation, and considering that certain manufacturers have been known to redefine the [colour white](https://www.reddit.com/r/androiddev/comments/71fpru/android_color_resources_not_safe/), the appearance of your app is effectively undefined.

#### Manifest (5252 bytes, 1% reduction)
We haven't touched the manifest yet, so there are some easy pickings here, namely removing:

```
android:allowBackup="true"
android:supportsRtl="true"
```

#### Proguard hack (4984 bytes, 5% reduction)
Let's refine our Proguard rule to remove `BuildConfig` and `R` from our Dex file.

```
-keep class com.fractalwrench.MainActivity { *; }
```

![classes.dex](/img/apkgolf/classes-dex.jpg)

#### Obfuscation (4936 bytes, 1% reduction)
Let's give our Activity an obfuscated name. Proguard does this automatically for regular classes, but as the manifest needs to know the Activity class name in order to launch it, this isn't obfuscated by default.

`MainActivity -> c.java`

`com.fractalwrench.apkgolf -> c.c`

### META-INF (3307 bytes, 33% reduction)
Currently we're signing our app with both a v1 and v2 signature. This seems wasteful, particularly as v2 offers [superior protection and performance](https://source.android.com/security/apksigning/#apk-signing-schemes), since it hashes the entire APK.

Our v2 signature isn't visible in the APK analyser, but is included as a binary block within the APK file itself. Our v1 signature is visible, in the form of `CERT.RSA` and `CERT.SF` files.

Let's uncheck the v1 signature checkbox in the Android Studio UI and generate a signed APK, and do the same for v2.

- v1: 3511 bytes
- v2: 3307 bytes

We have a winner!

## Where we're going, we won't need IDEs
It's time to edit our APK by hand. We'll be using the following commands:

```
# 1. Create an unsigned apk
./gradlew assembleRelease

# 2. Run zipalign
zipalign -v -p 4 app-release-unsigned.apk app-release-aligned.apk

# 3. Run apksigner with v2 signature
apksigner sign --v1-signing-enabled false --ks $HOME/fake.jks --out signed-release.apk app-release-unsigned.apk

# 4. Verify signature
apksigner verify signed-release.apk
```

A detailed overview of APK signing can be found [here](https://developer.android.com/studio/publish/app-signing.html#sign-manually). The process is essentially the same as within Android Studio. An unsigned archive is generated by gradle, uncompressed resources are zipaligned to reduce memory usage when the APK is loaded, and the file then has a v2 signature applied.

Our unsigned and unaligned APK weighs in at 1902 bytes, which indicates that we're currently using 1Kb for the signing/aligning features.

### Editing unzipped APK
After running `gradlew assembleRelease`, we can unzip the archive, then zip and sign the APK as described above.

```
unzip app-release-unsigned.apk -d app
zip -r app app.zip
```

### File-size discrepancy (2764 bytes, 17% reduction)
Weird! Unzipping the unaligned APK and signing it manually removes `META-INF/MANIFEST.MF`, saving us 543 bytes. If anybody knows why this is the case, please get in touch!

### resources.arsc (2608 bytes, 6% reduction)
We are left with 3 files that are included into the signed APK. We can get rid of one, `resources.arsc`, because it's empty since we're not defining any resources.

That leaves us with the manifest and the `classes.dex` file, each of which are roughly similar sizes.

### Compression Hacks (2599 bytes, 0.5% reduction)
Let's change all our remaining strings to 'c', update our versions to 26, then generate a signed APK.

```
compileSdkVersion 26
    buildToolsVersion "26.0.1"
    defaultConfig {
        applicationId "c.c"
        minSdkVersion 26
        targetSdkVersion 26
        versionCode 26
        versionName "26"
    }
```

```
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="c.c">

    <application
        android:icon="@android:drawable/btn_star"
        android:label="c"
        >
        <activity android:name="c.c.c">
```
The compression algorithm used to create an archive will reduce the file size further if some characters are more frequent than others. We can revisit this exploit later, but for now we've reclaimed 9 bytes.

### Hello ADB (2462 bytes, 5% reduction)
We can optimise our manifest further by removing the Launch intent filter for our activity. From now on, we'll use the following command to launch our app:

```
adb shell am start -a android.intent.action.MAIN -n c.c/.c
```

Here's our new manifest:

```
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="c.c">

    <application>
        <activity
            android:name="c"
            android:exported="true" />
    </application>
</manifest>
```

We've also got rid of our launcher icon.

### Reducing method references (2179 bytes, 12% reduction)
We got a functional APK which printed Hello World down to 2.5Kb, but our original requirements were just to install the APK on our device.

Our app references methods in `TextView`, `Bundle`, and `Activity`. We can reduce our Dex file size by removing this activity, and replacing it with a custom `Application` class. This should still generate a valid, albeit useless APK, and we'll have a single method reference in our Dex file of the `Application` constructor.

The source files for our app now look like this:

```
package c.c;
import android.app.Application;
public class c extends Application {}
```

```
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="c.c">
    <application android:name=".c" />
</manifest>
```

We'll use output from the adb to verify whether the APK installed successfully or not, and can also check in the Settings app.

![Apk installation proof](/img/apkgolf/package-installation-proof.jpg)

### Dex Optimisation (1961 bytes, 10% reduction)
I spent several hours researching the [Dex file format](https://source.android.com/devices/tech/dalvik/dex-format) for this optimisation, as the Dex file has various mechanisms such as checksums to ensure the validity of its contents.

 However, to cut a long story short, it turns out that the only requirement for APK installation is that a  `classes.dex` file must exist. Therefore, we're simply going to delete the original file, run `touch classes.dex` in the terminal, and gain a 10% reduction by using an empty file. Sometimes the stupidest solution is the best.

### Understanding the Manifest (1961 bytes, 0% reduction)
Our manifest from the unsigned APK is in a binary XML format which doesn't appear to be officially documented. We can use the [HexFiend](https://github.com/ridiculousfish/HexFiend) editor to manipulate the file byte by byte.

We can guess at a couple of interesting items in the file header - the first four bytes encode `38`, which is the same version number used for the Dex file. The next two bytes encode `660`, which is conveniently the file size.

Let's try deleting a byte by setting the targetSdkVersion to `1`, and updating the file size header to `659`. Unfortunately the Android system rejects this as an invalid APK, so it looks like there's some additional complexity here.

### Not understanding the Manifest (1777 bytes, 9% reduction)
Let's enter dummy characters throughout the file, and attempt to install the APK, without changing the file size. This will determine whether there's a checksum in place, or whether the change in file size caused a parsing error due to offset values in the file header no longer being correct.

Surprisingly, the following file can be installed within an APK on a Nexus 5X:

![Non-essential manifest parts](/img/apkgolf/non-essential-manifest-parts.jpg)

I think I can hear the Android Framework Engineer responsible for maintaining `BinaryXMLParser.java` screaming very loudly into a pillow.

If you recall our compression hack from earlier, we can repeat this by replacing everything non-essential with null bytes. This should also make it a lot easier to see the important parts of the manifest file in HexFiend.

#### UTF-8
![Minified AndroidManifest](/img/apkgolf/minified-android-manifest.png)

A few things are immediately obvious - such as the manifest and package tags. The versionCode and package name are also found in the string pool.

#### Hexadecimal
![Minified AndroidManifest](/img/apkgolf/minified-android-manifest-hex.png)

Viewing the file in hexadecimal shows values in the file header which describe the string pool and other values. Strings also have an interesting encoding - if they exceed 8 bytes, their total length is specified in the 2 preceding bytes.

### Done? (1757 bytes, 1% reduction)
Let's inspect the final APK.

![Name in signed APK](/img/apkgolf/name-in-signed-apk.png)

After all this time, I left my name in the APK via the v2 signature. Let's create a new keystore that exploits the compression hack.

![Keystore ccccccc](/img/apkgolf/cccccc.png)

That saved us 20 bytes.

### Stage 5: Acceptance
`1757` bytes is pretty damn small, and as far as I'm aware, this is the smallest APK in existence.

However, I'm reasonably confident that someone out there in the Android community can make further optimisations which will beat my score. If you manage to improve on `1757` bytes, please [send a PR to the repository](https://github.com/fractalwrench/ApkGolf) where the smallest APK is hosted.

A few starting ideas include:

- Reducing the file size of `AndroidManifest.xml`
- Brute-force generation of keystores to improve compression
- Further compression hacks by finding the most commonly used byte value

### Thank You
I hope you've enjoyed learning about the internals of an Android APK. If you have any questions or would like to suggest a topic that you'd like me to write about, please [get in touch](https://twitter.com/fractalwrench)!
